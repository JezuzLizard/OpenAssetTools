delimiters "$", "$"

import "Common.stg"

import "Loading/Common.stg"
import "Loading/ArrayPointer.stg"
import "Loading/Embedded.stg"
import "Loading/SinglePointer.stg"
import "Loading/PointerArray.stg"

// Loading common
LoaderClassName(asset) ::= "Loader_$asset.Type.Name$"

HeaderConstructor(context) ::= "$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream);"

HeaderSinglePtrLoadMethodDeclaration(structure) ::= "void LoadPtr_$structure.Type.Name$(bool atStreamStart);"
HeaderArrayLoadMethodDeclaration(type) ::= "void LoadArray_$SafeTypeName(type)$(bool atStreamStart, size_t count);"
HeaderPtrArrayLoadMethodDeclaration(type) ::= "void LoadPtrArray_$SafeTypeName(type)$(bool atStreamStart, size_t count);"
HeaderLoadMethodDeclaration(structure) ::= "void Load_$structure.Type.Name$(bool atStreamStart);"

HeaderGetNameMethodDeclaration(asset) ::= "static std::string GetAssetName($asset.Type.FullName$* pAsset);"
HeaderAssetLoadMethodDeclaration(asset) ::= "void LoadAsset_$asset.Type.Name$($asset.Type.FullName$** pAsset);"
HeaderMainLoadMethodDeclaration(asset) ::= "void Load($asset.Type.FullName$** pAsset);"

VariableDeclaration(type) ::= <<
$type.FullName$* var$SafeTypeName(type)$;
>>

PointerVariableDeclaration(type) ::= <<
$type.FullName$** var$SafeTypeName(type)$Ptr;
>>

// =======================
// Header file entry point
// =======================
header(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#pragma once

#include "Loading/AssetLoader.h"
#include "Game/$context.Game$/$context.Game$.h"
#include <string>

namespace $context.Game$
{
    class $LoaderClassName(context.Asset)$ final : public AssetLoader
    {
        $VariableDeclaration(context.Asset.Type)$
        $PointerVariableDeclaration(context.Asset.Type)$

        $context.UsedTypes:{type | $if(type.Information && !type.Information.Type.IsAnonymous && !type.Information.IsLeaf && !type.Information.IsAsset)$$VariableDeclaration(type.Type)$
            $endif$}$
        $context.UsedTypes:{type | $if(type.PointerArrayReferenceExists && !type.IsContextAsset)$$PointerVariableDeclaration(type.Type)$
            $endif$}$$\\$

        $context.UsedTypes:{usedType | $if(usedType.PointerArrayReferenceExists)$$HeaderPtrArrayLoadMethodDeclaration(usedType.Type)$$\n$$endif$}$
        $context.UsedTypes:{usedType | $if(usedType.ArrayReferenceExists && usedType.Information && !usedType.Information.IsLeaf)$$HeaderArrayLoadMethodDeclaration(usedType.Type)$$\n$$endif$}$
        $context.UsedStructures:{usedStructure | $if(!usedStructure.IsLeaf && !usedStructure.IsAsset)$$HeaderLoadMethodDeclaration(usedStructure)$$\n$$endif$}$
        $HeaderLoadMethodDeclaration(context.Asset)$
        $HeaderSinglePtrLoadMethodDeclaration(context.Asset)$
        $HeaderAssetLoadMethodDeclaration(context.Asset)$

    public:
        $HeaderConstructor(context)$
        $HeaderMainLoadMethodDeclaration(context.Asset)$
        $HeaderGetNameMethodDeclaration(context.Asset)$
    };
}
>>

LoadMember(context, member) ::= <<
Loading member $member.Member.Name$
>>

LoadMemberReference(context, structure, member, reference) ::= <%
$if(reference.IsSinglePointer)$
$\n$$\n$
$LoadSinglePointer(context, structure, member, reference)$
$elseif(reference.IsArrayPointer)$
$\n$$\n$
$LoadArrayPointer(context, structure, member, reference)$
$elseif(reference.IsPointerArray)$
$\n$$\n$
$LoadPointerArray(context, structure, member, reference)$
$elseif(reference.IsArray && !reference.NextReference)$
$\n$$\n$
$LoadEmbeddedArray(context, structure, member, reference)$
$elseif(!reference.Reference)$
$\n$$\n$
$LoadEmbedded(context, structure, member, reference)$
$else$
$\n$$\n$
// $member.Member.Name$
$endif$
%>

LoadMemberIfNeedsTreatment(context, structure, member) ::= <%
$if(!member.Computations.ShouldIgnore)$

$if(member.IsString || member.IsScriptString)$
$LoadMemberReference(context, structure, member, member.Computations.References)$
$elseif(member.Computations.ContainsNonEmbeddedReference)$
$LoadMemberReference(context, structure, member, member.Computations.References)$
$elseif(member.StructureType && !member.StructureType.IsLeaf)$
$LoadMemberReference(context, structure, member, member.Computations.References)$
$endif$

$endif$
%>

LoadSinglePtrMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadPtr_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypePtrVarName(structure.Type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$*>($TypePtrVarName(structure.Type)$);
    
    m_stream->PushBlock($structure.Block.Name$);
    
    if(*$TypePtrVarName(structure.Type)$ != nullptr)
    {
        $if(structure.Block.IsTemp)$
        if(*$TypePtrVarName(structure.Type)$ == PTR_FOLLOWING || *$TypePtrVarName(structure.Type)$ == PTR_INSERT)
        $else$
        if(*$TypePtrVarName(structure.Type)$ == PTR_FOLLOWING)
        $endif$
        {
            $if(structure.Block.IsTemp)$
            $structure.Type.FullName$** toInsert = nullptr;
            if(*$TypePtrVarName(structure.Type)$ == PTR_INSERT)
                toInsert = m_stream->InsertPointer<$structure.Type.FullName$>();
        
            $endif$
            *$TypePtrVarName(structure.Type)$ = m_stream->Alloc<$structure.Type.FullName$>(alignof($structure.Type.FullName$));

            $if(!structure.IsLeaf)$
            $TypeVarName(structure.Type)$ = *$TypePtrVarName(structure.Type)$;
            Load_$structure.Type.Name$(true);
            $endif$

            $if(structure.IsAsset)$
            LoadAsset_$structure.Type.Name$($TypePtrVarName(structure.Type)$);
            $endif$
            $if(structure.Block.IsTemp)$
        
            if(toInsert != nullptr)
                *toInsert = *$TypePtrVarName(structure.Type)$;
            $endif$
        }
        else
        {
            $if(structure.Block.IsTemp)$
            *$TypePtrVarName(structure.Type)$ = m_stream->ConvertOffsetToAlias(*$TypePtrVarName(structure.Type)$);
            $else$
            *$TypePtrVarName(structure.Type)$ = m_stream->ConvertOffsetToPointer(*$TypePtrVarName(structure.Type)$);
            $endif$
        }
    }
    
    m_stream->PopBlock();
}
>>

LoadArrayMethod(context, type, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadArray_$type.Name$(const bool atStreamStart, const size_t count)
{
    assert($TypeVarName(type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$type.FullName$>($TypeVarName(type)$, count);

    for(size_t index = 0; index < count; index++)
    {
        $if(!type.Members)$
        $TypeVarName(structure.Type)$ = $TypeVarName(type)$;
        $endif$
        Load_$structure.Type.Name$(false);
        $TypeVarName(type)$++;
    }
}
>>

LoadMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::Load_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypeVarName(structure.Type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$>($TypeVarName(structure.Type)$);$\\$
    $if(structure.ReferenceFromNonDefaultNormalBlockExists || structure.IsAsset)$

    m_stream->PushBlock($context.DefaultNormalBlock.Name$);$\\$
    $endif$
    $structure.OrderedMembers:{member | $LoadMemberIfNeedsTreatment(context, structure, member)$}$
    $if(structure.ReferenceFromNonDefaultNormalBlockExists || structure.IsAsset)$

    m_stream->PopBlock();
    $endif$
}
>>

VariableInitialization(type) ::= <<
var$type.Name$ = nullptr;
>>

PointerVariableInitialization(type) ::= <<
var$type.Name$Ptr = nullptr;
>>

ConstructorMethod(context) ::= <<
$LoaderClassName(context.Asset)$::$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream) 
    : AssetLoader($context.Asset.AssetEnumEntry.Name$, scriptStringProvider, zone, stream)
{
    $VariableInitialization(context.Asset.Type)$
    $PointerVariableInitialization(context.Asset.Type)$

    $context.UsedTypes:{type | $if(type.Information && !type.Information.Type.IsAnonymous && !type.Information.IsLeaf && !type.Information.IsAsset)$$VariableInitialization(type.Type)$
    $endif$}$
    $context.UsedTypes:{type | $if(type.Information && type.PointerArrayReferenceExists && !type.IsContextAsset)$$PointerVariableInitialization(type.Type)$
    $endif$}$$\\$
}
>>

LoadAssetMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadAsset_$structure.Type.Name$($structure.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);
    *pAsset = static_cast<$structure.Type.FullName$*>(LinkAsset(GetAssetName(*pAsset), *pAsset));
}
>>

MainLoadMethod(context) ::= <<
void $LoaderClassName(context.Asset)$::Load($context.Asset.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);

    $TypePtrVarName(context.Asset.Type)$ = pAsset;
    LoadPtr_$context.Asset.Type.Name$(false);
}
>>

GetNameMethod(context) ::= <<
std::string $LoaderClassName(context.Asset)$::GetAssetName($context.Asset.Type.FullName$* pAsset)
{
$if(context.Asset.NameChain)$
    return pAsset->$first(context.Asset.NameChain):{member | $member.Member.Name$}$$rest(context.Asset.NameChain):{member | .$member.Member.Name$}$;
$else$
    return "$context.Asset.Type.Name$";
$endif$
}
>>

IncludeHeaderOfOtherAsset(asset) ::= <<
#include "../$Lower(asset.Type.Name)$/$Lower(asset.Type.Name)$_load_db.h"

>>

// =======================
// Source file entry point
// =======================
source(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#include "$Lower(context.Asset.Type.Name)$_load_db.h"
#include <cassert>

// Referenced Assets:
$context.ReferencedAssets:IncludeHeaderOfOtherAsset()$

using namespace $context.Game$;

$ConstructorMethod(context)$

$context.UsedTypes:{usedType | $if(usedType.PointerArrayReferenceExists)$$LoadPointerArrayMethod(context, usedType.Type, usedType.Information, usedType.PointerArrayReferenceIsReusable)$$\n$$\n$$endif$}$
$context.UsedTypes:{usedType | $if(usedType.ArrayReferenceExists && usedType.Information && !usedType.Information.IsLeaf)$$LoadArrayMethod(context, usedType.Type, usedType.Information)$$\n$$\n$$endif$}$
$context.UsedStructures:{usedStructure | $if(!usedStructure.IsLeaf && !usedStructure.IsAsset)$$LoadMethod(context, usedStructure)$$\n$$\n$$endif$}$
$LoadMethod(context, context.Asset)$

$LoadSinglePtrMethod(context, context.Asset)$

$LoadAssetMethod(context, context.Asset)$

$MainLoadMethod(context)$

$GetNameMethod(context)$
>>