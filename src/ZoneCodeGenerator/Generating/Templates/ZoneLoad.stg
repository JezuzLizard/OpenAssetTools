delimiters "$", "$"

import "Common.stg"

import "Loading/Common.stg"
import "Loading/String.stg"
import "Loading/ArrayPointer.stg"
import "Loading/Embedded.stg"
import "Loading/SinglePointer.stg"

// Loading common
LoaderClassName(asset) ::= "Loader_$asset.Type.Name$"

HeaderConstructor(context) ::= "$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream);"

HeaderSinglePtrLoadMethodDeclaration(structure) ::= "void LoadPtr_$structure.Type.Name$(bool atStreamStart);"
HeaderArrayPtrLoadMethodDeclaration(structure) ::= "void LoadArray_$structure.Type.Name$(bool atStreamStart, size_t count);"
HeaderLoadMethodDeclaration(structure) ::= "void Load_$structure.Type.Name$(bool atStreamStart);"

HeaderGetNameMethodDeclaration(asset) ::= "static std::string GetAssetName($asset.Type.FullName$* pAsset);"
HeaderAssetLoadMethodDeclaration(asset) ::= "void LoadAsset_$asset.Type.Name$($asset.Type.FullName$** pAsset);"
HeaderMainLoadMethodDeclaration(asset) ::= "void Load($asset.Type.FullName$** pAsset);"

VariableDeclaration(type) ::= <<
$type.FullName$* var$type.Name$;
>>

PointerVariableDeclaration(type) ::= <<
$type.FullName$** var$type.Name$Ptr;
>>

HeaderDeclaration(structure) ::= <%
$if(structure.SinglePointerReferenceExists)$
$HeaderSinglePtrLoadMethodDeclaration(structure)$
$\n$
$endif$

$if(structure.ArrayPointerReferenceExists && !structure.IsLeaf)$
$HeaderArrayPtrLoadMethodDeclaration(structure)$
$\n$
$endif$

$if(!structure.IsLeaf && structure.Computations.IsUsed)$
$HeaderLoadMethodDeclaration(structure)$
$\n$
$endif$
%>

// =======================
// Header file entry point
// =======================
header(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#pragma once

#include "Loading/AssetLoader.h"
#include "Game/$context.Game$/$context.Game$.h"
#include <string>

namespace $context.Game$
{
    class $LoaderClassName(context.Asset)$ final : public AssetLoader
    {
        $VariableDeclaration(context.Asset.Type)$
        $PointerVariableDeclaration(context.Asset.Type)$
        $context.MemberTypes:{type | $if(!type.IsAnonymous)$$VariableDeclaration(type)$
            $endif$}$
        $context.Structures:{structure | $if(!structure.IsAsset && structure.SinglePointerReferenceExists)$$PointerVariableDeclaration(structure.Type)$
            $endif$}$
        $context.Structures:{structure | $if(!structure.IsAsset)$$HeaderDeclaration(structure)$$endif$}$
        $HeaderLoadMethodDeclaration(context.Asset)$
        $HeaderSinglePtrLoadMethodDeclaration(context.Asset)$
        $HeaderAssetLoadMethodDeclaration(context.Asset)$

    public:
        $HeaderConstructor(context)$
        $HeaderMainLoadMethodDeclaration(context.Asset)$
        $HeaderGetNameMethodDeclaration(context.Asset)$
    };
}
>>

LoadMember(context, member) ::= <<
Loading member $member.Member.Name$
>>


LoadMemberIfNeedsTreatment(context, structure, member) ::= <%
$if(member.IsString)$
$LoadString(context, structure, member)$
$elseif(member.IsScriptString)$
// Load scriptstring for $member.Member.Name$
$elseif(member.Computations.IsArrayPointerReference && member.Computations.PointerDepthIsOne)$
$LoadArrayPointer(context, structure, member)$
$elseif(member.Computations.IsSinglePointerReference)$
$LoadSinglePointer(context, structure, member)$
$elseif(member.Computations.IsEmbeddedReference && member.StructureType && !member.StructureType.IsLeaf)$
$LoadEmbedded(context, structure, member)$
$endif$
%>

LoadMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::Load_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypeVarName(structure)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$>($TypeVarName(structure)$);
    $if(structure.Block.IsTemp)$

    m_stream->PushBlock($context.DefaultNormalBlock.Name$);
    $endif$
    
    $structure.OrderedMembers:{member | $LoadMemberIfNeedsTreatment(context, structure, member)$}$
    $if(structure.Block.IsTemp)$
    m_stream->PopBlock();
    $endif$
}
>>

LoadSinglePtrMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadPtr_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypePtrVarName(structure)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$*>($TypePtrVarName(structure)$);
    
    m_stream->PushBlock($structure.Block.Name$);
    
    if(*$TypePtrVarName(structure)$ != nullptr)
    {
        $if(structure.Block.IsTemp)$
        if(*$TypePtrVarName(structure)$ == PTR_FOLLOWING || *$TypePtrVarName(structure)$ == PTR_INSERT)
        $else$
        if(*$TypePtrVarName(structure)$ == PTR_FOLLOWING)
        $endif$
        {
            $if(structure.Block.IsTemp)$
            $structure.Type.FullName$** toInsert = nullptr;
            if(*$TypePtrVarName(structure)$ == PTR_INSERT)
                toInsert = m_stream->InsertPointer<$structure.Type.FullName$>();
        
            $endif$
            *$TypePtrVarName(structure)$ = m_stream->Alloc<$structure.Type.FullName$>(alignof($structure.Type.FullName$));

            $if(!structure.IsLeaf)$
            $TypeVarName(structure)$ = *$TypePtrVarName(structure)$;
            Load_$structure.Type.Name$(true);
            $endif$

            $if(structure.IsAsset)$
            LoadAsset_$structure.Type.Name$($TypePtrVarName(structure)$);
            $endif$
            $if(structure.Block.IsTemp)$
        
            if(toInsert != nullptr)
                *toInsert = *$TypePtrVarName(structure)$;
            $endif$
        }
        else
        {
            $if(structure.Block.IsTemp)$
            *$TypePtrVarName(structure)$ = m_stream->ConvertOffsetToAlias(*$TypePtrVarName(structure)$);
            $else$
            *$TypePtrVarName(structure)$ = m_stream->ConvertOffsetToPointer(*$TypePtrVarName(structure)$);
            $endif$
        }
    }
    
    m_stream->PopBlock();
}
>>

LoadArrayPtrMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadArray_$structure.Type.Name$(const bool atStreamStart, const size_t count)
{
    assert($TypeVarName(structure)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$>($TypeVarName(structure)$, count);

    for(size_t index = 0; index < count; index++)
    {
        Load_$structure.Type.Name$(false);
        $TypeVarName(structure)$++;
    }
}
>>

SourceDefinition(structure, context) ::= <<
$if(structure.SinglePointerReferenceExists)$
$LoadSinglePtrMethod(structure, context)$

$endif$
$if(structure.ArrayPointerReferenceExists && !structure.IsLeaf)$
$LoadArrayPtrMethod(structure, context)$

$endif$
$if(!structure.IsLeaf && structure.Computations.IsUsed)$
$LoadMethod(structure, context)$

$endif$
>>

VariableInitialization(type) ::= <<
var$type.Name$ = nullptr;
>>

PointerVariableInitialization(type) ::= <<
var$type.Name$Ptr = nullptr;
>>

ConstructorMethod(context) ::= <<
$LoaderClassName(context.Asset)$::$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream) 
    : AssetLoader($context.Asset.AssetEnumEntry.Name$, scriptStringProvider, zone, stream)
{
    $VariableInitialization(context.Asset.Type)$
    $PointerVariableInitialization(context.Asset.Type)$
    $context.MemberTypes:{type | $if(!type.IsAnonymous)$$VariableInitialization(type)$
        $endif$}$
    $context.Structures:{structure | $if(!structure.IsAsset && structure.SinglePointerReferenceExists)$$PointerVariableInitialization(structure.Type)$
        $endif$}$
}
>>

LoadAssetMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadAsset_$structure.Type.Name$($structure.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);
    *pAsset = static_cast<$structure.Type.FullName$*>(LinkAsset(GetAssetName(*pAsset), *pAsset));
}
>>

MainLoadMethod(context) ::= <<
void $LoaderClassName(context.Asset)$::Load($context.Asset.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);

    $TypePtrVarName(context.Asset)$ = pAsset;
    LoadPtr_$context.Asset.Type.Name$(false);
}
>>

GetNameMethod(context) ::= <<
std::string $LoaderClassName(context.Asset)$::GetAssetName($context.Asset.Type.FullName$* pAsset)
{
$if(context.Asset.NameChain)$
    return pAsset->$first(context.Asset.NameChain):{member | $member.Member.Name$}$$rest(context.Asset.NameChain):{member | .$member.Member.Name$}$;
$else$
    return "$context.Asset.Type.Name$";
$endif$
}
>>

IncludeHeaderOfOtherAsset(asset) ::= <<
#include "../$Lower(asset.Type.Name)$/$Lower(asset.Type.Name)$_load_db.h"

>>

// =======================
// Source file entry point
// =======================
source(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#include "$Lower(context.Asset.Type.Name)$_load_db.h"
#include <cassert>

// Referenced Assets:
$context.ReferencedAssets:IncludeHeaderOfOtherAsset()$

using namespace $context.Game$;

$ConstructorMethod(context)$

$context.Structures:{structure | $if(!structure.IsAsset)$$SourceDefinition(structure, context)$$endif$}$
$LoadMethod(context.Asset, context)$

$LoadAssetMethod(context.Asset, context)$

$LoadSinglePtrMethod(context.Asset, context)$

$MainLoadMethod(context)$

$GetNameMethod(context)$
>>