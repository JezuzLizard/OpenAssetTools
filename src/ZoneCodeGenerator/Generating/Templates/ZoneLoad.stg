delimiters "$", "$"

import "Common.stg"

Capital(name) ::= "$name; format=\"cap\"$"
Lower(name) ::= "$name; format=\"lower\"$"

LoaderClassName(asset) ::= "Loader_$asset.Type.Name$"

HeaderConstructor(context) ::= "$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream);"

HeaderSinglePtrLoadMethodDeclaration(structure) ::= "void LoadPtr_$structure.Type.Name$($structure.Type.FullName$** pPtr);"
HeaderArrayPtrLoadMethodDeclaration(structure) ::= "void LoadArray_$structure.Type.Name$($structure.Type.FullName$** pArray, size_t count, bool atStreamStart);"
HeaderLoadMethodDeclaration(structure) ::= "void Load_$structure.Type.Name$($structure.Type.FullName$* p$structure.Type.Name$, bool atStreamStart);"

HeaderGetNameMethodDeclaration(asset) ::= "static std::string GetAssetName($asset.Type.FullName$* p$asset.Type.Name$);"
HeaderAssetLoadMethodDeclaration(asset) ::= "void LoadAsset_$asset.Type.Name$($asset.Type.FullName$** pPtr);"

HeaderDeclaration(structure) ::= <%
$if(structure.SinglePointerReferenceExists)$
$HeaderSinglePtrLoadMethodDeclaration(structure)$
$\n$
$endif$

$if(structure.ArrayPointerReferenceExists)$
$HeaderArrayPtrLoadMethodDeclaration(structure)$
$\n$
$endif$

$if(structure.NonEmbeddedReferenceExists)$
$HeaderLoadMethodDeclaration(structure)$
$\n$
$endif$
%>

// =======================
// Header file entry point
// =======================
header(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#pragma once

#include "Loading/AssetLoader.h"
#include "Game/$context.Game$/$context.Game$.h"
#include <string>

namespace $context.Game$
{
    class $LoaderClassName(context.Asset)$ final : public AssetLoader
    {
		$context.Structures:{structure | $if(!structure.IsAsset)$$HeaderDeclaration(structure)$$endif$}$
		$HeaderLoadMethodDeclaration(context.Asset)$
		$HeaderAssetLoadMethodDeclaration(context.Asset)$

    public:
		$HeaderConstructor(context)$

		$HeaderSinglePtrLoadMethodDeclaration(context.Asset)$
		$HeaderGetNameMethodDeclaration(context.Asset)$
    };
}
>>

IncludeHeaderOfOtherAsset(asset) ::= <<
#include "../$Lower(asset.Type.Name)$/$Lower(asset.Type.Name)$_load_db.h"

>>

LoadMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::Load_$structure.Type.Name$($structure.Type.FullName$* p$structure.Type.Name$, const bool atStreamStart)
{
	assert(p$structure.Type.Name$ != nullptr);

	if(atStreamStart)
		m_stream->Load<$structure.Type.FullName$>();
	$if(structure.Block.IsTemp)$

	m_stream->PushBlock($context.DefaultNormalBlock.Name$);
	$endif$
	
	// Load content here
	$if(structure.Block.IsTemp)$

	m_stream->PopBlock();
	$endif$
}
>>

LoadSinglePtrMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadPtr_$structure.Type.Name$($structure.Type.FullName$** pPtr)
{
    assert(pPtr != nullptr);
	
    m_stream->PushBlock($structure.Block.Name$);
    
	if(*pPtr != nullptr)
	{
		$if(structure.Block.IsTemp)$
		if(*pPtr == PTR_FOLLOWING || *pPtr == PTR_INSERT)
		$else$
		if(*pPtr == PTR_FOLLOWING)
		$endif$
		{
			$if(structure.Block.IsTemp)$
			$structure.Type.FullName$** toInsert = nullptr;
			if(*pPtr == PTR_INSERT)
				toInsert = m_stream->InsertPointer<$structure.Type.FullName$>();
        
			$endif$
			$if(structure.HasNonDefaultAlign)$
            *pPtr = m_stream->Alloc<$structure.Type.FullName$>($structure.FastFileAlign$);
			$else$
            *pPtr = m_stream->Alloc<$structure.Type.FullName$>();
			$endif$
			Load_$structure.Type.Name$(*pPtr, true);
			$if(structure.IsAsset)$
			LoadAsset_$structure.Type.Name$(pPtr);
			$endif$
			$if(structure.Block.IsTemp)$
        
			if(toInsert != nullptr)
				*toInsert = *pPtr;
			$endif$
		}
		else
		{
			$if(structure.Block.IsTemp)$
			*pPtr = m_stream->ConvertOffsetToAlias(*pPtr);
			$else$
			*pPtr = m_stream->ConvertOffsetToPointer(*pPtr);
			$endif$
		}
	}
	
    m_stream->PopBlock();
}
>>

LoadArrayPtrMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadArray_$structure.Type.Name$($structure.Type.FullName$** pArray, const size_t count, const bool atStreamStart)
{
	assert(pArray != nullptr);

	if(atStreamStart)
		m_stream->Load<$structure.Type.FullName$>(count);

	for(size_t index = 0; index < count; index++)
	{
		Load_$structure.Type.Name$(&(*pArray)[index], false);
	}
}
>>

SourceDefinition(structure, context) ::= <<
$if(structure.NonEmbeddedReferenceExists)$
$LoadMethod(structure, context)$

$endif$
$if(structure.SinglePointerReferenceExists)$
$LoadSinglePtrMethod(structure, context)$

$endif$
$if(structure.ArrayPointerReferenceExists)$
$LoadArrayPtrMethod(structure, context)$

$endif$
>>

ConstructorMethod(context) ::= <<
$LoaderClassName(context.Asset)$::$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream) 
    : AssetLoader($context.Asset.AssetEnumEntry.Name$, scriptStringProvider, zone, stream){}
>>

LoadAssetMethod(structure, context) ::= <<
void $LoaderClassName(context.Asset)$::LoadAsset_$structure.Type.Name$($structure.Type.FullName$** pPtr)
{
    assert(pPtr != nullptr);
    *pPtr = static_cast<$structure.Type.FullName$*>(LinkAsset(GetAssetName(*pPtr), *pPtr));
}
>>

GetNameMethod(context) ::= <<
std::string $LoaderClassName(context.Asset)$::GetAssetName($context.Asset.Type.FullName$* p$context.Asset.Type.Name$)
{
$if(context.Asset.HasNameMember)$
    return p$context.Asset.Type.Name$->name;
$else$
	return "$context.Asset.Type.Name$";
$endif$
}
>>

// =======================
// Source file entry point
// =======================
source(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#include "$Lower(context.Asset.Type.Name)$_load_db.h"
#include <cassert>

// Referenced Assets:
$context.ReferencedAssets:IncludeHeaderOfOtherAsset()$

using namespace $context.Game$;

$ConstructorMethod(context)$

$context.Structures:{structure | $if(!structure.IsAsset)$$SourceDefinition(structure, context)$$endif$}$
$LoadMethod(context.Asset, context)$

$LoadAssetMethod(context.Asset, context)$

$LoadSinglePtrMethod(context.Asset, context)$

$GetNameMethod(context)$
>>