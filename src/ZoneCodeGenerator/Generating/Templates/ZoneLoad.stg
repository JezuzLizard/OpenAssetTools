delimiters "$", "$"

import "Common.stg"

import "Loading/Common.stg"
import "Loading/ArrayPointer.stg"
import "Loading/DynamicArray.stg"
import "Loading/Embedded.stg"
import "Loading/SinglePointer.stg"
import "Loading/PointerArray.stg"

// Loading common
LoaderClassName(asset) ::= "Loader_$asset.Type.Name$"

HeaderConstructor(context) ::= "$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream);"

HeaderTempPtrLoadMethodDeclaration(structure) ::= "void LoadPtr_$structure.Type.Name$(bool atStreamStart);"
HeaderArrayLoadMethodDeclaration(type) ::= "void LoadArray_$SafeTypeName(type)$(bool atStreamStart, size_t count);"
HeaderPtrArrayLoadMethodDeclaration(type) ::= "void LoadPtrArray_$SafeTypeName(type)$(bool atStreamStart, size_t count);"
HeaderLoadMethodDeclaration(structure) ::= "void Load_$structure.Type.Name$(bool atStreamStart);"

HeaderGetNameMethodDeclaration(asset) ::= "static std::string GetAssetName($asset.Type.FullName$* pAsset);"
HeaderAssetLoadMethodDeclaration(asset) ::= "void LoadAsset_$asset.Type.Name$($asset.Type.FullName$** pAsset);"
HeaderMainLoadMethodDeclaration(asset) ::= "XAssetInfo<$asset.Type.FullName$>* Load($asset.Type.FullName$** pAsset);"

VariableDeclaration(type) ::= <<
$type.FullName$* var$SafeTypeName(type)$;
>>

PointerVariableDeclaration(type) ::= <<
$type.FullName$** var$SafeTypeName(type)$Ptr;
>>

// =======================
// Header file entry point
// =======================
header(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#pragma once

#include "Loading/AssetLoader.h"
#include "Game/$context.Game$/$context.Game$.h"
$if(context.HasActions)$
#include "Game/$context.Game$/XAssets/$Lower(context.Asset.Type.Name)$/$Lower(context.Asset.Type.Name)$_actions.h"
$endif$
#include <string>

namespace $context.Game$
{
    class $LoaderClassName(context.Asset)$ final : public AssetLoader
    {
        XAssetInfo<$context.Asset.Type.FullName$>* m_asset_info;
        $if(context.HasActions)$
        Actions_$context.Asset.Type.Name$ m_actions;
        $endif$
        $VariableDeclaration(context.Asset.Type)$
        $PointerVariableDeclaration(context.Asset.Type)$

        $context.UsedTypes:{type | $if(type.Information && !type.Information.Type.IsAnonymous && !type.Information.IsLeaf && !type.Information.IsAsset)$$VariableDeclaration(type.Type)$
            $endif$}$
        $context.UsedTypes:{type | $if(type.PointerArrayReferenceExists && !type.IsContextAsset)$$PointerVariableDeclaration(type.Type)$
            $endif$}$$\\$

        $context.UsedTypes:{usedType | $if(usedType.PointerArrayReferenceExists)$$HeaderPtrArrayLoadMethodDeclaration(usedType.Type)$$\n$$endif$}$
        $context.UsedTypes:{usedType | $if(usedType.ArrayReferenceExists && usedType.Information && !usedType.Information.IsLeaf && usedType.NonRuntimeReferenceExists)$$HeaderArrayLoadMethodDeclaration(usedType.Type)$$\n$$endif$}$
        $context.UsedStructures:{usedStructure | $if(usedStructure.NonRuntimeReferenceExists && !usedStructure.Information.IsLeaf && !usedStructure.Information.IsAsset)$$HeaderLoadMethodDeclaration(usedStructure.Information)$$\n$$endif$}$
        $HeaderLoadMethodDeclaration(context.Asset)$
        $HeaderTempPtrLoadMethodDeclaration(context.Asset)$
        $HeaderAssetLoadMethodDeclaration(context.Asset)$

    public:
        $HeaderConstructor(context)$
        $HeaderMainLoadMethodDeclaration(context.Asset)$
        $HeaderGetNameMethodDeclaration(context.Asset)$
    };
}
>>

LoadMemberReference_Array(context, structure, member, reference) ::= <<
$first(reference.ArrayEntries):{entry | $LoadMemberReference(context, structure, member, entry)$}$
$rest(reference.ArrayEntries):{entry | 

$LoadMemberReference(context, structure, member, entry)$}$
>>

LoadMemberReference(context, structure, member, reference) ::= <%
$if(reference.IsDynamicArray)$
$LoadDynamicArray(context, structure, member, reference)$
$elseif(reference.IsSinglePointer)$
$LoadSinglePointer(context, structure, member, reference)$
$elseif(reference.IsArrayPointer)$
$LoadArrayPointer(context, structure, member, reference)$
$elseif(reference.IsPointerArray)$
$LoadPointerArray(context, structure, member, reference)$
$elseif(reference.IsArray && !reference.NextReference)$
$LoadEmbeddedArray(context, structure, member, reference)$
$elseif(!reference.Reference)$
$LoadEmbedded(context, structure, member, reference)$
$elseif(reference.IsArray)$
$LoadMemberReference_Array(context, structure, member, reference)$
$else$
// LoadMemberReference failed @ $member.Member.Name$
$endif$
%>

LoadMemberCondition_Struct(context, structure, member) ::= <<


$if(member.Condition)$
if($PrintEvaluation(member.Condition)$)
{
    $LoadMemberReference(context, structure, member, member.Computations.References)$
}$\\$
$else$
$LoadMemberReference(context, structure, member, member.Computations.References)$$\\$
$endif$
>>

LoadMemberCondition_Union(context, structure, member) ::= <<
$if(member.Computations.IsFirstMember)$$\\$
$if(member.Condition)$

if($PrintEvaluation(member.Condition)$)
{
    $LoadMemberReference(context, structure, member, member.Computations.References)$
}$\\$
$else$

$LoadMemberReference(context, structure, member, member.Computations.References)$$\\$
$endif$$\\$
$elseif(member.Computations.IsLastMember)$$\\$
$if(member.Condition)$
else if($PrintEvaluation(member.Condition)$)
{
    $LoadMemberReference(context, structure, member, member.Computations.References)$
}$\\$
$else$
else
{
    $LoadMemberReference(context, structure, member, member.Computations.References)$
}$\\$
$endif$$\\$
$else$$\\$
$if(member.Condition)$
else if($PrintEvaluation(member.Condition)$)
{
    $LoadMemberReference(context, structure, member, member.Computations.References)$
}$\\$
$else$$\\$
#error Middle member of union must have condition ($member.Member.Name$)
$endif$$\\$
$endif$
>>

LoadMemberCondition(context, structure, member) ::= <%
$if(structure.IsUnion)$
$LoadMemberCondition_Union(context, structure, member)$
$else$
$LoadMemberCondition_Struct(context, structure, member)$
$endif$
%>

LoadMemberIfNeedsTreatment(context, structure, member) ::= <%
$if(!member.Computations.ShouldIgnore)$

$if(member.IsString || member.IsScriptString)$
$LoadMemberCondition(context, structure, member)$
$elseif(member.Computations.ContainsNonEmbeddedReference)$
$LoadMemberCondition(context, structure, member)$
$elseif(member.StructureType && !member.StructureType.IsLeaf)$
$LoadMemberCondition(context, structure, member)$
$elseif(member.Computations.IsAfterPartialLoad)$
$LoadMemberCondition(context, structure, member)$
$endif$

$endif$
%>

LoadTempPtrMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadPtr_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypePtrVarName(structure.Type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$structure.Type.FullName$*>($TypePtrVarName(structure.Type)$);
    
    m_stream->PushBlock($context.DefaultTempBlock.Name$);
    
    if(*$TypePtrVarName(structure.Type)$ != nullptr)
    {
        if(*$TypePtrVarName(structure.Type)$ == PTR_FOLLOWING || *$TypePtrVarName(structure.Type)$ == PTR_INSERT)
        {
            $structure.Type.FullName$* ptr = *$TypePtrVarName(structure.Type)$;
            *$TypePtrVarName(structure.Type)$ = m_stream->Alloc<$structure.Type.FullName$>(alignof($structure.Type.FullName$));
            
            $structure.Type.FullName$** toInsert = nullptr;
            if(ptr == PTR_INSERT)
                toInsert = m_stream->InsertPointer<$structure.Type.FullName$>();

            $if(!structure.IsLeaf)$
            $TypeVarName(structure.Type)$ = *$TypePtrVarName(structure.Type)$;
            Load_$structure.Type.Name$(true);
            $endif$

            $if(structure.PostLoadAction)$
            $CustomAction(structure.PostLoadAction)$
            $endif$

            $if(structure.IsAsset)$
            LoadAsset_$structure.Type.Name$($TypePtrVarName(structure.Type)$);
            $endif$
        
            if(toInsert != nullptr)
                *toInsert = *$TypePtrVarName(structure.Type)$;
        }
        else
        {
            *$TypePtrVarName(structure.Type)$ = m_stream->ConvertOffsetToAlias(*$TypePtrVarName(structure.Type)$);
        }
    }
    
    m_stream->PopBlock();
}
>>

LoadArrayMethod(context, type, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadArray_$type.Name$(const bool atStreamStart, const size_t count)
{
    assert($TypeVarName(type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$type.FullName$>($TypeVarName(type)$, count);

    $type.FullName$* var = $TypeVarName(type)$;
    for(size_t index = 0; index < count; index++)
    {
        $if(!type.Members)$
        $TypeVarName(structure.Type)$ = var;
        $else$
        $TypeVarName(type)$ = var;
        $endif$
        Load_$structure.Type.Name$(false);
        var++;
    }
}
>>

LoadMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::Load_$structure.Type.Name$(const bool atStreamStart)
{
    assert($TypeVarName(structure.Type)$ != nullptr);$\\$

    $if(!(structure.IsUnion && structure.Computations.DynamicMember))$

    if(atStreamStart)
        $if(!structure.Computations.DynamicMember)$
        m_stream->Load<$structure.Type.FullName$>($TypeVarName(structure.Type)$); // Size: $structure.Type.Size$$\\$
        $else$
        m_stream->LoadPartial<$structure.Type.FullName$>($TypeVarName(structure.Type)$, offsetof($structure.Type.FullName$, $structure.Computations.DynamicMember.Member.Name$));$\\$
        $endif$
    $else$
    assert(atStreamStart);$\\$
    $endif$
    $if(structure.Block)$

    m_stream->PushBlock($structure.Block.Name$);$\\$
    $elseif(structure.IsAsset)$

    m_stream->PushBlock($context.DefaultNormalBlock.Name$);$\\$
    $endif$
    $structure.OrderedMembers:{member | $LoadMemberIfNeedsTreatment(context, structure, member)$}$
    $if(structure.Block || structure.IsAsset)$

    m_stream->PopBlock();
    $endif$
}
>>

VariableInitialization(type) ::= <<
var$type.Name$ = nullptr;
>>

PointerVariableInitialization(type) ::= <<
var$type.Name$Ptr = nullptr;
>>

ConstructorMethod(context) ::= <<
$LoaderClassName(context.Asset)$::$LoaderClassName(context.Asset)$(IZoneScriptStringProvider* scriptStringProvider, Zone* zone, IZoneInputStream* stream) 
    : AssetLoader($context.Asset.AssetEnumEntry.Name$, scriptStringProvider, zone, stream)$\\$
    $if(context.HasActions)$, m_actions(zone)$endif$
{
    m_asset_info = nullptr;
    $VariableInitialization(context.Asset.Type)$
    $PointerVariableInitialization(context.Asset.Type)$

    $context.UsedTypes:{type | $if(type.Information && !type.Information.Type.IsAnonymous && !type.Information.IsLeaf && !type.Information.IsAsset)$$VariableInitialization(type.Type)$
    $endif$}$
    $context.UsedTypes:{type | $if(type.Information && type.PointerArrayReferenceExists && !type.IsContextAsset)$$PointerVariableInitialization(type.Type)$
    $endif$}$$\\$
}
>>

LoadAssetMethod(context, structure) ::= <<
void $LoaderClassName(context.Asset)$::LoadAsset_$structure.Type.Name$($structure.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);
    m_asset_info = reinterpret_cast<XAssetInfo<$structure.Type.FullName$>*>(LinkAsset(GetAssetName(*pAsset), *pAsset));
    *pAsset = m_asset_info->Asset();
}
>>

MainLoadMethod(context) ::= <<
XAssetInfo<$context.Asset.Type.FullName$>* $LoaderClassName(context.Asset)$::Load($context.Asset.Type.FullName$** pAsset)
{
    assert(pAsset != nullptr);

    m_asset_info = nullptr;

    $TypePtrVarName(context.Asset.Type)$ = pAsset;
    LoadPtr_$context.Asset.Type.Name$(false);

    if(m_asset_info == nullptr && *pAsset != nullptr)
        m_asset_info = reinterpret_cast<XAssetInfo<$context.Asset.Type.FullName$>*>(GetAssetInfo(GetAssetName(*pAsset)));

    return m_asset_info;
}
>>

GetNameMethod(context) ::= <<
std::string $LoaderClassName(context.Asset)$::GetAssetName($context.Asset.Type.FullName$* pAsset)
{
$if(context.Asset.NameChain)$
    return pAsset->$first(context.Asset.NameChain):{member | $member.Member.Name$}$$rest(context.Asset.NameChain):{member | .$member.Member.Name$}$;
$else$
    return "$context.Asset.Type.Name$";
$endif$
}
>>

IncludeHeaderOfOtherAsset(asset) ::= <<
#include "../$Lower(asset.Type.Name)$/$Lower(asset.Type.Name)$_load_db.h"

>>

// =======================
// Source file entry point
// =======================
source(context) ::= <<
// ====================================================================
// This file has been generated by ZoneCodeGenerator.
// Do not modify. 
// Any changes will be discarded when regenerating.
// ====================================================================

#include "$Lower(context.Asset.Type.Name)$_load_db.h"
#include <cassert>

// Referenced Assets:
$context.ReferencedAssets:IncludeHeaderOfOtherAsset()$

using namespace $context.Game$;

$ConstructorMethod(context)$

$context.UsedTypes:{usedType | $if(usedType.PointerArrayReferenceExists)$$LoadPointerArrayMethod(context, usedType.Type, usedType.Information, usedType.PointerArrayReferenceIsReusable)$$\n$$\n$$endif$}$
$context.UsedTypes:{usedType | $if(usedType.ArrayReferenceExists && usedType.Information && !usedType.Information.IsLeaf && usedType.NonRuntimeReferenceExists)$$LoadArrayMethod(context, usedType.Type, usedType.Information)$$\n$$\n$$endif$}$
$context.UsedStructures:{usedStructure | $if(usedStructure.NonRuntimeReferenceExists && !usedStructure.Information.IsLeaf && !usedStructure.Information.IsAsset)$$LoadMethod(context, usedStructure.Information)$$\n$$\n$$endif$}$
$LoadMethod(context, context.Asset)$

$LoadTempPtrMethod(context, context.Asset)$

$LoadAssetMethod(context, context.Asset)$

$MainLoadMethod(context)$

$GetNameMethod(context)$
>>