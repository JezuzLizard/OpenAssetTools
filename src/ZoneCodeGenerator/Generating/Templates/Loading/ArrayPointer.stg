delimiters "$", "$"

// Everything related to loading a pointer with a count that can be larger than 1

LoadArrayPointer_Loading(context, structure, member, reference) ::= <%
$TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$ = m_stream->Alloc<$TypeDeclaration(member.Member.VariableType)$$PrintFollowingReferences(reference.FollowingReferences)$>(alignof($TypeDeclaration(member.Member.VariableType)$$PrintFollowingReferences(reference.FollowingReferences)$)); 
// $member.Member.VariableType.Type.Alignment$
$\n$

$if(member.StructureType && !member.StructureType.IsLeaf)$

$TypeVarName(member.Member.VariableType.Type)$ = $TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$;$\n$
LoadArray_$member.Member.VariableType.Type.Name$(true, $PrintEvaluation(reference.ArrayPointerCountEvaluation)$);

$else$

m_stream->Load<$TypeDeclaration(member.Member.VariableType)$$PrintFollowingReferences(reference.FollowingReferences)$>($TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$, $PrintEvaluation(reference.ArrayPointerCountEvaluation)$);

$endif$
%>

LoadArrayPointer_ScriptString(context, structure, member, reference) ::= <%
$TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$ = m_stream->Alloc<$TypeDeclaration(member.Member.VariableType)$$PrintFollowingReferences(reference.FollowingReferences)$>(alignof($TypeDeclaration(member.Member.VariableType)$$PrintFollowingReferences(reference.FollowingReferences)$)); 
// $member.Member.VariableType.Type.Alignment$
$\n$

varScriptString = $TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$;$\n$
LoadScriptStringArray(true, $PrintEvaluation(reference.ArrayPointerCountEvaluation)$);

%>

LoadArrayPointer_TypeCheck(context, structure, member, reference) ::= <%
$if(member.IsScriptString)$
$LoadArrayPointer_ScriptString(context, structure, member, reference)$
$else$
$LoadArrayPointer_Loading(context, structure, member, reference)$
$endif$
%>

LoadArrayPointer_PointerCheck(context, structure, member, reference) ::= <<
if ($TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$)
{
    $if(member.IsReusable)$
    if($TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$ == PTR_FOLLOWING)
    {
        $LoadArrayPointer_TypeCheck(context, structure, member, reference)$
    }
    else
    {
        $TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$ = m_stream->ConvertOffsetToPointer($TypeVarName(structure.Type)$->$member.Member.Name$$PrintArrayIndices(reference)$);
    }
    $else$
    $LoadArrayPointer_TypeCheck(context, structure, member, reference)$
    $endif$
}
>>

LoadArrayPointer_Block(context, structure, member, reference) ::= <%
$if(member.Computations.IsNotDefaultNormalBlock)$
m_stream->PushBlock($member.Block.Name$);$\n$
$endif$

$LoadArrayPointer_PointerCheck(context, structure, member, reference)$

$if(member.Computations.IsNotDefaultNormalBlock)$
$\n$m_stream->PopBlock();
$endif$
%>

LoadArrayPointer(context, structure, member, reference) ::= <%
$LoadArrayPointer_Block(context, structure, member, reference)$
%>

LoadPointerArrayMethod_Loading(context, type, structure) ::= <%
*$TypePtrVarName(type)$ = m_stream->Alloc<$type.FullName$>(alignof($type.FullName$)); 
// $type.Alignment$
$\n$

$if(structure && !structure.IsLeaf)$

$TypeVarName(structure.Type)$ = *$TypePtrVarName(type)$;$\n$
Load_$type.Name$(true);

$else$

m_stream->Load<$type.FullName$>(*$TypePtrVarName(type)$);

$endif$
%>

LoadPointerArrayMethod_Asset(context, type, structure) ::= <<
$LoaderClassName(structure)$ loader(m_script_string_provider, m_zone, m_stream);
loader.Load($TypePtrVarName(type)$);
>>

LoadPointerArrayMethod_PointerCheck(context, type, structure, reusable) ::= <<
if (*$TypePtrVarName(type)$)
{
    $if(structure && structure.IsAsset)$
    $LoadPointerArrayMethod_Asset(context, type, structure)$
    $else$
    $if(reusable)$
    if(*$TypePtrVarName(type)$ == PTR_FOLLOWING)
    {
        $LoadPointerArrayMethod_Loading(context, type, structure)$
    }
    else
    {
        *$TypePtrVarName(type)$ = m_stream->ConvertOffsetToPointer(*$TypePtrVarName(type)$);
    }
    $else$
    $LoadPointerArrayMethod_Loading(context, type, structure)$
    $endif$
    $endif$
}
>>

LoadPointerArrayMethod(context, type, structure, reusable) ::= <<
void $LoaderClassName(context.Asset)$::LoadPtrArray_$SafeTypeName(type)$(const bool atStreamStart, const size_t count)
{
    assert($TypePtrVarName(type)$ != nullptr);

    if(atStreamStart)
        m_stream->Load<$type.FullName$*>($TypePtrVarName(type)$, count);

    for(size_t index = 0; index < count; index++)
    {
        $LoadPointerArrayMethod_PointerCheck(context, type, structure, reusable)$

        $TypePtrVarName(type)$++;
    }
}
>>